# This file is part of Marcel.
# 
# Marcel is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, (or at your
# option) any later version.
# 
# Marcel is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Marcel.  If not, see <https://www.gnu.org/licenses/>.

import marcel.argsparser
import marcel.core
import marcel.exception
import marcel.opmodule
import marcel.object.error
import marcel.util

HELP = '''
{L,wrap=F}join [-k|--keep] (| PIPELINE |)

{L,indent=4:28}{r:-k}, {r:--keep}              Write an output tuple from the left input even if there is no matching
tuple from the right input.

{L,indent=4:28}{r:PIPELINE}                The second (right) input to the join.

Computes a database-style join between the input stream, 
and a second stream from the given {r:PIPELINE}.

The input pipelines provides one input to the join, named {i:left}.
The {r:PIPELINE} argument provides the second input, named {i:right}.
Left and right tuples are matched by comparing their first elements. For matching
pairs, an output tuple consists of the left tuple followed by the right tuple with the
first value removed. (That would be redundant since the tuples were matched on their
first values.)

The {r:--keep} flag causes left inputs to be passed to output as is, when there is no
matching right input. (In database terms, this is a left join.)

{b:Example}

The left input has 6 tuples of the form {n:(x, -x)}, generated by {n:gen 6 | map (x: (x, -x))}.
The right input has 4 tuples of the form {n:(x, x**2)}, generated by {n:gen 4 | map (x: (x, x**2))}.
The join is computed as follows:

{L,wrap=F}gen 6 | map (x: (x, -x)) | join (| gen 4 | map (x: (x, x**2)) |)

This generates the following output:

{P,wrap=F,indent=4}
(0, 0, 0)
(1, -1, 1)
(2, -2, 4)
(3, -3, 9)

If the {r:--keep} flag were included, the output would have two additional rows:

{P,wrap=F,indent=4}
(0, 0, 0)
(1, -1, 1)
(2, -2, 4)
(3, -3, 9)
(4, -4)
(5, -5)
'''


def join(pipeline, keep=False):
    assert isinstance(pipeline, marcel.core.OpList)
    args = ['--keep'] if keep else []
    args.append(pipeline)
    return Join(), args


class JoinArgsParser(marcel.argsparser.ArgsParser):

    def __init__(self, env):
        super().__init__('join', env)
        self.add_flag_no_value('keep', '-k', '--keep')
        # str: To accommodate var names
        self.add_anon('pipelines', convert=self.check_pipeline, target='pipeline_arg')
        self.validate()


class Join(marcel.core.Op):

    def __init__(self):
        super().__init__()
        self.pipeline_arg = None
        self.keep = None
        self.inner = None  # Map containing contents of pipelines, keyed by join value

    def __repr__(self):
        return f'join(keep, {self.pipeline_arg})' if self.keep else f'join({self.pipeline_arg})'

    # AbstractOp

    def setup(self, env):
        pipeline = marcel.core.Pipeline.create(self.pipeline_arg, self.customize_pipeline)
        pipeline.setup(env)
        pipeline.run_pipeline(env, None)

    def receive(self, env, x):
        x = tuple(x)
        join_value = x[0]
        try:
            match = self.inner.get(join_value, None)
        except TypeError:
            raise marcel.exception.KillCommandException(f'{x} is not hashable')
        if match is None:
            if self.keep:
                self.send(env, x)
        elif type(match) is list:
            for m in match:
                self.send(env, x + m[1:])
        else:
            self.send(env, x + match[1:])

    # Internal

    def customize_pipeline(self, env, pipeline):
        def load_inner(*x):
            assert len(x) > 0
            x = tuple(x)
            join_value = x[0]
            try:
                match = self.inner.get(join_value, None)
                if match is None:
                    self.inner[join_value] = x
                elif type(match) is list:
                    match.append(x)
                else:
                    # match is first value associated with join_value, x is the second. Need a list.
                    self.inner[join_value] = [match, x]
            except TypeError:
                raise marcel.exception.KillCommandException(f'{x} is not hashable')

        self.inner = {}
        map = marcel.opmodule.create_op(env, 'map', load_inner)
        pipeline.append(map)
        return pipeline
