# This file is part of Marcel.
# 
# Marcel is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or at your
# option) any later version.
# 
# Marcel is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Marcel.  If not, see <https://www.gnu.org/licenses/>.

import marcel.argsparser
import marcel.core
import marcel.exception
import marcel.opmodule
import marcel.object.error
import marcel.util

HELP = '''
{L,wrap=F}join [-k|--keep] PIPELINE

{L,indent=4:28}{r:-k}, {r:--keep}              Write an output tuple from the left input even if there is no matching
tuple from the right input.

{L,indent=4:28}{r:PIPELINE}                The second (right) input to the join.

Computes a database-style join between the input stream, 
and a second stream from the given {r:PIPELINE}.

The input pipeline provides one input to the join, named {i:left}.
The {r:PIPELINE} argument provides the second input, named {i:right}.
Left and right tuples are matched by comparing their first elements. For matching
pairs, an output tuple consists of the left tuple followed by the right tuple with the
first value removed. (That would be redundant since the tuples were matched on their
first values.)

The {r:--keep} flag causes left inputs to be passed to output as is, when there is no
matching right input. (In database terms, this is a left join.)

{b:Example}

The left input has 6 tuples of the form {n:(x, -x)}, generated by {n:gen 6 | map (x: (x, -x))}.
The right input has 4 tuples of the form {n:(x, x**2)}, generated by {n:gen 4 | map (x: (x, x**2))}.
The join is computed as follows:

{L,wrap=F}gen 6 | map (x: (x, -x)) | join [ gen 4 | map (x: (x, x**2)) ]

This generates the following output:

{L,wrap=F,indent=4}
(0, 0, 0)
(1, -1, 1)
(2, -2, 4)
(3, -3, 9)

If the {r:--keep} flag were included, the output would have two additional rows:

{L,wrap=F,indent=4}
(0, 0, 0)
(1, -1, 1)
(2, -2, 4)
(3, -3, 9)
(4, -4)
(5, -5)
'''


def join(env, pipeline, keep=False):
    """
    Join a pipeline.

    Args:
        env: (todo): write your description
        pipeline: (todo): write your description
        keep: (bool): write your description
    """
    assert isinstance(pipeline, marcel.core.Pipelineable)
    args = ['--keep'] if keep else []
    args.append(pipeline.create_pipeline())
    return Join(env), args


class JoinArgsParser(marcel.argsparser.ArgsParser):

    def __init__(self, env):
        """
        Initialize the pipeline.

        Args:
            self: (todo): write your description
            env: (todo): write your description
        """
        super().__init__('join', env)
        self.add_flag_no_value('keep', '-k', '--keep')
        # str: To accommodate var names
        self.add_anon('pipeline', convert=self.check_str_or_pipeline)
        self.validate()


class Join(marcel.core.Op):

    def __init__(self, env):
        """
        Initialize the environment.

        Args:
            self: (todo): write your description
            env: (todo): write your description
        """
        super().__init__(env)
        self.pipeline = None
        self.keep = None
        self.inner = None  # Map containing contents of pipeline, keyed by join value

    def __repr__(self):
        """
        Return a human - readable representation of this object.

        Args:
            self: (todo): write your description
        """
        return 'join(keep)' if self.keep else 'join()'

    # AbstractOp

    def setup(self):
        """
        Run load_inner.

        Args:
            self: (todo): write your description
        """
        def load_inner(*x):
            """
            Load inner inner inner inner inner inner inner inner inner inner inner inner values.

            Args:
                x: (str): write your description
            """
            assert len(x) > 0
            x = tuple(x)
            join_value = x[0]
            match = self.inner.get(join_value, None)
            if match is None:
                self.inner[join_value] = x
            elif type(match) is list:
                match.append(x)
            else:
                # match is first value associated with join_value, x is the second. Need a list.
                self.inner[join_value] = [match, x]
        super().setup()
        env = self.env()
        self.inner = {}
        pipeline = marcel.core.Op.pipeline_arg_value(env, self.pipeline).copy()
        pipeline.set_error_handler(self.owner.error_handler)
        map = marcel.opmodule.create_op(env, 'map', load_inner)
        pipeline.append(map)
        marcel.core.Command(env, None, pipeline).execute()

    def receive(self, x):
        """
        Receive the given value to the queue.

        Args:
            self: (todo): write your description
            x: (todo): write your description
        """
        x = tuple(x)
        join_value = x[0]
        match = self.inner.get(join_value, None)
        if match is None:
            if self.keep:
                self.send(x)
        elif type(match) is list:
            for m in match:
                self.send(x + m[1:])
        else:
            self.send(x + match[1:])
