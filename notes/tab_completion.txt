What should be tab-completed?

- Op names

- Flags?

- Expected args? Basically, turning tab completion into help facility.

- cd: directories

- ls: files, symlinks, directories

----------------------------------------------------------------------

bash:

- Does command completion

- Does file completion for current directory only (with no
  input). Then, it looks for completions of what's been typed.

- "ls -" does flag completion (just listing them, no help). Long versions only.

- file completion seems to be done for all commands, even when it
  doesn't make sense (e.g. ps)

- ps doesn't do flag completion.

----------------------------------------------------------------------

General command completion:

For an op: set of op names.

After op:

      -: list flags for the op
      
      other: for an op expecting filenames: Contents of pwd, and /

Parser state and op are needed.

----------------------------------------------------------------------

Bug 98: Autocomplete doesn't work in pipeline

    l<tab>
    load  loop  ls 

    ls | args [l<tab>

doesn't show any options.

Time for an overhaul of tab completion. The tracking of the last token
(CurrentOp class) by parsing for tab completion was only accidentally
working for non-nested pipelines, and broken for nested ones. And not
readily fixable. The problem is that once the parse is past a token,
the relevant CurrentOp is popped and no longer available. So in the
case of l<tab>, the CurrentOp is args (because we're completely done
with "l"). In the first case above that "worked", (no nested pipeline)
there was a bug in which "l" was on the stack after popping "l" from
the stack!

Parser state:

- tokens: List of Token
- t: index into tokens, next token to process.
- token: The current token, tokens[t-1] 
- current_pipelines: Stack of Pipelines

Tab completion sees tokens, a token may be:

- an op: ls
- a partially-typed op: l
- a flag or any prefix: -, --, -x, --xy, -xyz
- A string arg: abc, 'abc', "abc", a\ bc
- an expression: (...)
- punctuation: |, >, >>, !, !!, [, ], (, ), @, =, #, <comma>, :

It CANNOT be:

- a partial expression: (.... An exception should be thrown if we run
  out of text before the expression is complete.

Parse can also end with an exception


Tab completion needs to know:

- context: is text an op or partial op? arg? 

- whether text is current token or previous one (e.g. expr that
  couldn't be parsed).

Observations:

l<tab>:         text=<l>, token=String(l)

ls<tab>:        text=<ls>, token=Op(ls)

ls <tab>:       text=<>, token=Op(ls)

ls (<tab>:      text=<>, token=

   Parser() blows up in Lexer, and is uncaught by TabCompleter.candidates!

ls -<tab>:      text=<->, token=String(-)

ls |<tab>:      text=<>, token=Pipe(|), KCE (premature end)

ls | args [<tab>:        text=<>, token=Begin([), KCE (premature end)

......................................................................

ls<tab>:        Do op completion.
ls <tab>:       Op is complete. Do filename completion.

The problem is that the parse doesn't see whitespace. Lexer can help,
adding info to Tokens, e.g. Token.adjacent_to_previous.

======================================================================

Tab completion bugs:

----------------------------------------------------------------------

128. Tab completion vs. syntactic sugar

For "var > ..." or "./file > ...", tab completion doesn't work. Tab
completion for first symbol expects executable.

----------------------------------------------------------------------

147. Space after tab-completion is broken

Sometimes there's a space when there shouldn't be, and vice versa.

Check ops, args, filenames.

----------------------------------------------------------------------

July 2023

Tab completion broken again. test_tab_completion.py had disabled
tests! There's been bitrot. TabCompletionContext tracking is easy to
break. It gets maintained at random places in the parse code, it's not
systematic. Parsing code gets changed, tab context isn't maintained
(and apparently has not been tested).

What *should* happen:

Line           Completion       Completion
               type

<tab> (1)      none             <none>

l<tab>         op               ls, load

ls<tab>        op               "ls "

ls <tab>       arg              <local files>

ls x<tab>      arg              <local files beginning with x>

ls (<tab>      none             Inside an expression, don't do any completion

ls -<tab>      arg              short and long flags of ls

ls --<tab>     arg              long flags of ls

ls |<tab> (1)  none

ls | <tab> (2) none

ls | args [<tab>        text=<>, token=Begin([), KCE (premature end)


(1) bash does not do tab completion on empty line

(2) bash does do completion on line with only whitespace. Seems to
show all executables as well as legal bash symbols. Doesn't seem very
useful, so don't bother.

......................................................................


     op     arg      
A    B CD   E  F G   

A: Before op: no TC (tab completion)

B: Inside op: TC for op

C: op complete but no whitespace yet: TC for op (should be just the op
   itself, unless the op is a prefix of another).

D: Before arg: TC for arg

E: Inside arg: TC for arg

F: TC for arg

G: TC for (next) arg

----------------------------------------------------------------------

Information needed to determine tab completion:

- Which token, 1st or subsequent?

- Is last char whitespace? Determines whether to complete last string
  or find candidates for empty string of next token.

----------------------------------------------------------------------

2/19/25:

Parsing this:

    ls "a

ShellString is created for "a. String.scan() ends with unmatched
quote, but doesn't indicate this in any way. Should it raise
PrematureEndError, or something similar?

PEE is currently thrown when an op or arg is expected but not found.

Could throw PEE and include the incomplete string. That incomplete
string is then the correct value of text for tab completion (as
opposed to the value provided by readline, which is ignorant of
quotes, and just goes by whitespace).

Tab completion:

    Text             unquoted                 '...                     "...

    <text>           yes                      yes                      yes

    ~/<text>         yes                      yes                      no

    ~<text>          yes(2)                   no                       no

    /<text>          yes                      yes                      yes

    ./<text>         yes                      yes                      yes

    ../<text>        yes                      yes                      yes

    <text><space>    no(1)                    yes                      yes

    <text>\<space>   yes                      no                       no

1. touch "a b"; ls a<space>: Tab completion lists all files. The a (no
space) is left as an arg to ls even though there is no such
file. I.e., there is no quote, so the space following a is interpreted
as an arg separator by the shell.

2. Complete using usernames in /etc/passwd 


So:

+ text to complete: Use what is reported by readline except if
  MissingQuoteException occurs. In that case, use the text from the
  exception (with the leading quote).

- Do tab completion as is done right now, except for double-quoted
  ~/...

*** If text was quoted, then the selected completion should be quoted
  too. How does this happen?

- parser.String.scan needs to handle \<space>

......................................................................

2/20/25:

touch "f 1" "f 2"

Bash tab completion:

- ls f<tab> ->

  ls f\ 
  f 1   f 2

- ls "f<tab> ->
  ls "f<space>
  f 1   f 2

- ls "f 1<tab> ->
  ls "f 1"<space>

......................................................................

To edit the displayed line:

readline.insert_text(string)

    Insert text into the line buffer at the cursor position. This
    calls rl_insert_text() in the underlying library, but ignores the
    return value.

readline.redisplay()

    Change whatâ€™s displayed on the screen to reflect the current
    contents of the line buffer. This calls rl_redisplay() in the
    underlying library.

Might be useful for inserting quotesx
M 0.30.7 jao@loon /tmp/d$ ls acomplete: text=<a>, state=0
candidates: line=ls a, text=<a>
No exception
TabCompleter.candidates, is token op: False
complete_filenames, text = <a>
complete_filename candidates for a: ['ab', 'ac']
complete: text=<a>, state=1
candidates: line=ls a, text=<a>
No exception
TabCompleter.candidates, is token op: False
complete_filenames, text = <a>
complete_filename candidates for a: ['ab', 'ac']
complete: text=<a>, state=2
candidates: line=ls a, text=<a>
No exception
TabCompleter.candidates, is token op: False
complete_filenames, text = <a>
complete_filename candidates for a: ['ab', 'ac']
